/* EGR */

#include <hw_types.h>
#include <soc_AM335x.h>
#include <hw_gpio_v2.h>
#include <interrupt.h>
#include <uartStdio.h>
#include "EGR_Cape.h"
#include "Conf_mod.h"
#include "GPIO.h"

//Interrupt Service Routine
void myGPIO2Isr() {
	//Taster1(Forward)
	if((HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS(0)) & (1 << GPIO_PORT1_PIN2)) != 0) {
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_1_MODUL, GPIO_H_BRUECKE_MOTOR1_1, PIN_LOW);
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_2_MODUL, GPIO_H_BRUECKE_MOTOR1_2, PIN_HIGH);
		//Drehrichtungen von Motor1 und Motor2 soll gegenteilig sein.
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_1_MODUL, GPIO_H_BRUECKE_MOTOR2_1, PIN_HIGH);
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_2_MODUL, GPIO_H_BRUECKE_MOTOR2_2, PIN_LOW);
		UARTprintf("Taster1!");
		//loeschen des Interrupt Flags
		HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS(0)) |= (1 << GPIO_PORT1_PIN2);
	}

	//Taster2(Reverse)
	if((HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS(0)) & (1 << GPIO_PORT1_PIN4)) != 0) {
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_1_MODUL, GPIO_H_BRUECKE_MOTOR1_1, PIN_HIGH);
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_2_MODUL, GPIO_H_BRUECKE_MOTOR1_2, PIN_LOW);
		//Drehrichtungen von Motor1 und Motor2 soll gegenteilig sein.
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_1_MODUL, GPIO_H_BRUECKE_MOTOR2_1, PIN_LOW);
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_2_MODUL, GPIO_H_BRUECKE_MOTOR2_2, PIN_HIGH);
		UARTprintf("Taster2!");
		//loeschen des Interrupt Flags
		HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS(0)) |= (1 << GPIO_PORT1_PIN4);
	}

	//Taster3(Brake)
	if((HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS(0)) & (1 << GPIO_PORT1_PIN6)) != 0) {
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_1_MODUL, GPIO_H_BRUECKE_MOTOR1_1, PIN_HIGH);
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_2_MODUL, GPIO_H_BRUECKE_MOTOR1_2, PIN_HIGH);
		//Drehrichtungen von Motor1 und Motor2 soll gegenteilig sein.
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_1_MODUL, GPIO_H_BRUECKE_MOTOR2_1, PIN_HIGH);
		EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_2_MODUL, GPIO_H_BRUECKE_MOTOR2_2, PIN_HIGH);
		UARTprintf("Taster3!");
		//loeschen des Interrupt Flags
		HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS(0)) |= (1 << GPIO_PORT1_PIN6);
	}
}

int main() {
	//Taster
	//muxing to GPIO, Pullup
	PinMuxing(CONF_PORT1_PIN2, PULL_ENABLE, PULL_UP, GPIO_MODE);
	PinMuxing(CONF_PORT1_PIN4, PULL_ENABLE, PULL_UP, GPIO_MODE);
	PinMuxing(CONF_PORT1_PIN6, PULL_ENABLE, PULL_UP, GPIO_MODE);
	//pin als input setzen
	EGR_GPIODirSet(GPIO_PORT1_PIN2_MODUL, GPIO_PORT1_PIN2, GPIO_INPUT);
	EGR_GPIODirSet(GPIO_PORT1_PIN4_MODUL, GPIO_PORT1_PIN4, GPIO_INPUT);
	EGR_GPIODirSet(GPIO_PORT1_PIN6_MODUL, GPIO_PORT1_PIN6, GPIO_INPUT);

	//Motor
	//muxing to GPIO
	PinMuxing(CONF_H_BRUECKE_MOTOR1_1, PULL_DISABLE, PULL_UP, GPIO_MODE);
	PinMuxing(CONF_H_BRUECKE_MOTOR1_2, PULL_DISABLE, PULL_UP, GPIO_MODE);
	PinMuxing(CONF_H_BRUECKE_MOTOR2_1, PULL_DISABLE, PULL_UP, GPIO_MODE);
	PinMuxing(CONF_H_BRUECKE_MOTOR2_2, PULL_DISABLE, PULL_UP, GPIO_MODE);
	//pin als output setzen
	EGR_GPIODirSet(GPIO_H_BRUECKE_MOTOR1_1_MODUL, GPIO_H_BRUECKE_MOTOR1_1, GPIO_OUTPUT);
	EGR_GPIODirSet(GPIO_H_BRUECKE_MOTOR1_2_MODUL, GPIO_H_BRUECKE_MOTOR1_2, GPIO_OUTPUT);
	EGR_GPIODirSet(GPIO_H_BRUECKE_MOTOR2_1_MODUL, GPIO_H_BRUECKE_MOTOR2_1, GPIO_OUTPUT);
	EGR_GPIODirSet(GPIO_H_BRUECKE_MOTOR2_2_MODUL, GPIO_H_BRUECKE_MOTOR2_2, GPIO_OUTPUT);

	//Initialstate als Standby
	EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_1_MODUL, GPIO_H_BRUECKE_MOTOR1_1, PIN_LOW);
	EGR_PinWrite(GPIO_H_BRUECKE_MOTOR1_2_MODUL, GPIO_H_BRUECKE_MOTOR1_2, PIN_LOW);
	EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_1_MODUL, GPIO_H_BRUECKE_MOTOR2_1, PIN_LOW);
	EGR_PinWrite(GPIO_H_BRUECKE_MOTOR2_2_MODUL, GPIO_H_BRUECKE_MOTOR2_2, PIN_LOW);

	//GPIO-Interrupt konfiguration
	//initialisiere ARM Interrupt Controller
	IntAINTCInit();
	//globale Interruptsteuerung aktivieren
	IntMasterIRQEnable();
	//lokale Interruptquelle aktivieren
	IntSystemEnable(SYS_INT_GPIOINT2A);
	//Registrierung der Funktion auf GPIO2-Interrupt A
	IntRegister(SYS_INT_GPIOINT2A, myGPIO2Isr);
	//Interrupt-Trigger setzen
	//Pin aufloesen
	HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS_SET(0)) |= (1 << GPIO_PORT1_PIN2);
	HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS_SET(0)) |= (1 << GPIO_PORT1_PIN4);
	HWREG(SOC_GPIO_2_REGS + GPIO_IRQSTATUS_SET(0)) |= (1 << GPIO_PORT1_PIN6);
	//Ereignis an Pin aktivieren
	HWREG(SOC_GPIO_2_REGS + GPIO_RISINGDETECT) |= (1 << GPIO_PORT1_PIN2);
	HWREG(SOC_GPIO_2_REGS + GPIO_RISINGDETECT) |= (1 << GPIO_PORT1_PIN4);
	HWREG(SOC_GPIO_2_REGS + GPIO_RISINGDETECT) |= (1 << GPIO_PORT1_PIN6);

	return 0;
}
